#version 460
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_shader_atomic_int64 : require
#extension GL_EXT_shader_image_int64 : require
#extension GL_GOOGLE_include_directive : enable
#include "shader_structures.glsl"

struct Vertex{
	float inPosition[3];
	float inColor[4];
	float inRadius;
};


layout (set = 0, binding = 0) uniform UniformBlock { matrices_and_user_input uboMatricesAndUserInput; };
layout (set = 0, binding = 1) buffer writeonly LinesDist{ float lineDist[]; } ;
layout (set = 0, binding = 2) buffer readonly SourceIndexBuffer{ uint indices[]; };
layout (set = 0, binding = 3) buffer readonly VertexBuffer{ Vertex vertex[]; } ;
layout (set = 0, binding = 4) buffer LineSourceSrc{ uint id[]; } lineSrc;
layout (set = 0, binding = 5) buffer LineSourceDst{ uint id[]; } lineDst;

#define WORKGROUP_SIZE          16
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	//ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	//if (any(greaterThanEqual(coord, imgSize.xy))) return;

	// calculet distance and fill lineSrc buffer
	for(uint i = gl_GlobalInvocationID.x; i < uboMatricesAndUserInput.mNumberOfLines % WORKGROUP_SIZE; ++i )
	{
		uint l_0 = indices[2 * i];
		uint l_1 = indices[2 * i + 1];

		Vertex c0 = vertex[l_0];
		Vertex c1 = vertex[l_1];
		vec4 posVS0 = uboMatricesAndUserInput.mViewMatrix * vec4(c0.inPosition[0], c0.inPosition[1], c0.inPosition[2], 1.0);
		vec4 posVS1 = uboMatricesAndUserInput.mViewMatrix * vec4(c1.inPosition[0], c1.inPosition[1], c1.inPosition[2], 1.0);
		float minDist = min(length(posVS0), length(posVS1));

		lineDist[i] = minDist;
		lineSrc.id[i] = i;
	}

	// wait for the first loop to complete on all threads
	barrier();


}